var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference-1","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"(Image: )","category":"page"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"poisson_op\nlaplacian_op\nfwi_op","category":"page"},{"location":"api/#FwiFlow.poisson_op","page":"API Reference","title":"FwiFlow.poisson_op","text":"poisson_op(c::Union{PyObject, Float64}, g::Union{PyObject, Float64}, \n    h::Union{PyObject, Float64}, ρ::Union{PyObject, Float64}, index::Union{Integer, PyObject}=0)\n\nSolves the Poisson equation (mathbfx=z x^T)\n\nbeginaligned\n-nablacdotleft(c(mathbfx) nabla left(u(mathbfx) -rho  beginbmatrixz  0endbmatrix   right)right) =  g(mathbfx)  mathbfxin Omega\nfracpartial u(x)partial n =  0  mathbfxin Omega\nendaligned\n\nHere Omega=0n_zhtimes 0 n_xh. The equation is solved using finite difference method, where the step size in each direction is h. Mathematically, the solution to the PDE is determined up to a constant. Numerically, we discretize the equation with the scheme\n\n(A+E_11)mathbfu = mathbff\n\nwhere A is the finite difference coefficient matrix,\n\n(E_11)_ij = begincases1  i=j=1  0  mbox otherwise endcases\n\nWhen index=1, the Eigen SparseLU is used to solve the linear system; otherwise the function invokes algebraic multigrid method from amgcl. \n\n\n\n\n\n","category":"function"},{"location":"api/#FwiFlow.laplacian_op","page":"API Reference","title":"FwiFlow.laplacian_op","text":"laplacian_op(coef::Union{PyObject, Array{Float64}}, f::Union{PyObject, Array{Float64}}, \n        h::Union{PyObject, Float64}, ρ::Union{PyObject, Float64})\n\nComputes the Laplacian of function f(mathbfx); here (mathbfx=z x^T)\n\n-nablacdotleft(c(mathbfx) nabla left(u(mathbfx) -rho beginbmatrixz  0endbmatrix  right)right)\n\n\n\n\n\n","category":"function"},{"location":"api/#FwiFlow.fwi_op","page":"API Reference","title":"FwiFlow.fwi_op","text":"fwiop(cp::Union{PyObject, Array{Float64}},cs::Union{PyObject, Array{Float64}},     den::Union{PyObject, Array{Float64}},stf::Union{PyObject, Array{Float64}},     gpuid::Union{PyObject, Integer},shotids::Union{PyObject, Array{T}},parafname::String) where T<:Integer\n\nComputes the FWI loss function. \n\ncp : P-wave velocity\ncs : S-wave velocity\nden : Density \nstf : Source time functions  \ngpu_id : the ID of GPU to run this FWI operator\nshot_ids : the source function IDs (determining the location of sources)\npara_fname : parameter file location\n\n\n\n\n\n","category":"function"},{"location":"README/#FwiFlow-1","page":"FwiFlow","title":"FwiFlow","text":"","category":"section"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"<img src=\"../assets/diagram.png\" style=\"zoom:67%;\" />","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"This project consider the coupling of the wave equation and a two-phase incompressible immiscible flow equation, mainly for CO2 injection or water injection monitoring","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"utt = m(x) uxx + f(x,t)","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"m_t = grad(a(x)grad(m)) + b(x)*grad(m)","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"The time scale T2 for the second equation is much larger than that of the first one T1","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"T2 >> T1","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"a(x), b(x) are unknown functions and will be calibrated using observation data di(x), which depends on ui for each observation time i","category":"page"},{"location":"README/#Instruction-1","page":"FwiFlow","title":"Instruction","text":"","category":"section"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"Compile AdvectionDiffusion","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"cd Ops/AdvectionDiffusion/\nmkdir build\ncd build\ncmake ..\nmake -j","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"Test AdvectionDiffusion and Generate Data (required)","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"julia> include(\"cdtest.jl\")\njulia> include(\"gradtest.jl\")","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"Compile CUFA","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"cd Ops/FWI/CUFD/Src\nmake -j","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"Compile Wrapper","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"cd Ops/FWI/ops/build\ncmake ..\nmake -j","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"Generate data","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"julia> include(\"generate_m.jl\")\npython main_calc_obs_data.py\npython fwitest.py","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"Test Wrapper","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"cd src","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"julia> include(\"fwi_gradient_check.jl\")\njulia> include(\"coupled_gradient_check\")","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"Run experiments","category":"page"},{"location":"README/#","page":"FwiFlow","title":"FwiFlow","text":"julia> include(\"learn_m.jl\")","category":"page"},{"location":"#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"#General-Problem-1","page":"Getting Started","title":"General Problem","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"This framework uses waveform data to invert for intrinsic parameters (e.g., permeability and porosity) in subsurface problems, with coupled flow physics, rock physics, and wave physics models.","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"#Physical-Models-1","page":"Getting Started","title":"Physical Models","text":"","category":"section"},{"location":"#Flow-Physics-1","page":"Getting Started","title":"Flow Physics","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"The flow physics component maps from intrinsic properties such as permeability to flow properties, such as fluid saturation. We use a model of two-phase flow in porous media as an example. The governing equations are convervation of mass, Darcy's law, and other relationships.","category":"page"},{"location":"#Rock-Physics-1","page":"Getting Started","title":"Rock Physics","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"The rock physics model describes the relationship between fluid properties and rock elastic properties. As one fluid phase displaces the other, the bulk modulus and density of rocks vary. ","category":"page"},{"location":"#Wave-Physics-1","page":"Getting Started","title":"Wave Physics","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"The elastic wave equation maps from elastic properties to wavefields, such as particle velocity and stress, which can be recorded by receiver arrays as seismic waveform data.","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"The elastic wave equation maps from elastic properties to wavefields, such as particle velocity and stress, which can be recorded by receiver arrays as seismic waveform data.","category":"page"},{"location":"#Intelligent-Automatic-Differentiation-1","page":"Getting Started","title":"Intelligent Automatic Differentiation","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"The Intelligent Automatic Differentiation method provides three levels of user control with (1) built-in differentiable operators from modern deep-learning infrastructures (TensorFlow), and customized operators that can either (2) encapsulate analytic adjoint gradient computation or (3) handle the forward simulation and compute the corresponding gradient for a single time step. This intelligent strategy strikes a good balance between computational efficiency and programming efficiency and would serve as a paradigm for a wide range of PDE-constrained geophysical inverse problems.","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"###\tThe Adjoint Method & Automatic Differentation","category":"page"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"#The-Adjoint-Method-and-Automatic-Differentation-1","page":"Getting Started","title":"The Adjoint Method & Automatic Differentation","text":"","category":"section"},{"location":"#Customized-Operators-1","page":"Getting Started","title":"Customized Operators","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"###\tCustomized Operators","category":"page"}]
}
